(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{485:function(r,n,t){"use strict";t.r(n);var e=t(8),_=Object(e.a)({},(function(){var r=this,n=r._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[n("p",[r._v("create date: 2023-04-01 17:52"),n("br"),r._v("\nStatus: #notes\nTags: [[c语言]] [[编程]]")]),r._v(" "),n("hr"),r._v(" "),n("h1",{attrs:{id:"引用与指针的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#引用与指针的区别"}},[r._v("#")]),r._v(" 引用与指针的区别")]),r._v(" "),n("p",[r._v("一、概念"),n("br"),r._v("\n指针：指针是一个变量，只不过这个变量存储的是一个地址，指向"),n("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[r._v("内存"),n("OutboundLink")],1),r._v("的一个存储单元。"),n("br"),r._v("\n引用：引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。"),n("br"),r._v("\n引用的特性："),n("br"),r._v("\n（1）引用在定义时必须初始化；"),n("br"),r._v("\n（2）一个变量可以有多个引用；"),n("br"),r._v("\n（3）引用一旦绑定了一个实体，就不能再改变为其它变量的引用。")]),r._v(" "),n("p",[r._v("二、引用和指针的区别与联系"),n("br"),r._v("\n1.引用和指针有什么区别？"),n("br"),r._v("\n本质：引用是别名，指针是地址，具体的："),n("br"),r._v("\n①从现象上看，指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。"),n("br"),r._v("\n②从内存分配上看，程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。"),n("br"),r._v("\n注：标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器 http://bbs.csdn.net/topics/320095541"),n("br"),r._v("\n③ 从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。"),n("br"),r._v("\n④不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。"),n("br"),r._v("\n⑤理论上，对于指针的级数没有限制，但是引用只能是一级。如下："),n("br"),r._v("\nint** p1; // 合法。指向指针的指针"),n("br"),r._v("\nint*& p2; // 合法。指向指针的引用"),n("br"),r._v("\nint&* p3; // 非法。指向引用的指针是非法的"),n("br"),r._v("\nint&& p4; // 非法。指向引用的引用是非法的"),n("br"),r._v("\n注意上述读法是从左到右。")]),r._v(" "),n("p",[r._v("2.不同点"),n("br"),r._v("\n（1）引用定义时必须初始化，指针可以不用初始化；"),n("br"),r._v("\n（2）引用一旦初始化为指向一个对象，就不能再指向其他对象，而指针可以在任何时候指向任何一个同类型的对象；"),n("br"),r._v("\n（3）没有空引用，但是有空指针；"),n("br"),r._v("\n（4）在sizeof中的含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节的个数（在32为平台下，指针求sizeof永远是"),n("br"),r._v("\n（5）引用++改变的是变量的内容，指针++改变的是指针的指向；"),n("br"),r._v("\n（6）有多级指针，但没有多级引用；"),n("br"),r._v("\n（7）引用使用起来比指针更安全；"),n("br"),r._v("\n（8）如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；")]),r._v(" "),n("h1",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[r._v("#")]),r._v(" references")]),r._v(" "),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/weixin_41167925/article/details/119708650?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-119708650-blog-93623647.235%5Ev27%5Epc_relevant_default&spm=1001.2101.3001.4242.2&utm_relevant_index=4",target:"_blank",rel:"noopener noreferrer"}},[r._v("(3条消息) 指针与引用的区别_老朽在门外的博客-CSDN博客"),n("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=_.exports}}]);