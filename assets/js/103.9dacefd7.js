(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{417:function(a,e,s){"use strict";s.r(e);var t=s(8),n=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"makefile-缩写注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#makefile-缩写注意事项"}},[a._v("#")]),a._v(" makefile 缩写注意事项")]),a._v(" "),e("ul",[e("li",[a._v("变量使用“＝”时，以下内容会实时更新curname的值，相当于指针的作用：")])]),a._v(" "),e("div",{staticClass:"language-md line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("name = zzk\ncurname = $(name)\nname = jxx\nprint:\n\t@echo curname: $(curname) #输出：curname: jxx\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("ul",[e("li",[e("p",[a._v('而使用":=",则不会这样，相当于是值拷贝；')])]),a._v(" "),e("li",[e("p",[a._v('使用"?="的结果又有不同，如果变量curname前面没有被赋值，那么此变量就是此时所赋的值，反之，使用前面的赋值')])]),a._v(" "),e("li",[e("p",[a._v('使用"+="时，相当于对字符串进行追加操作，有一个类似字符串拼接的操作')])])]),a._v(" "),e("h2",{attrs:{id:"makefile的模式规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#makefile的模式规则"}},[a._v("#")]),a._v(" makefile的模式规则")]),a._v(" "),e("div",{staticClass:"language-md line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-md"}},[e("code",[a._v("%.o: %.c\n\tcommand\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("p",[a._v("上述规则中，%符号匹配的是长度任意的非空字符串，而目标中的%符号代表了依赖中的%代表的值，如匹配出test.o: test.c;")]),a._v(" "),e("h2",{attrs:{id:"makefile中的自动化变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#makefile中的自动化变量"}},[a._v("#")]),a._v(" makefile中的自动化变量")]),a._v(" "),e("p",[a._v("自动化只出现在规则的命令中，会把模式中所定义的一系列的文件自动的挨个取出，直至所有的符合模式的文件都取完。\n有以下自动化变量：")]),a._v(" "),e("ul",[e("li",[a._v("$@ 匹配模式中定义的目标集合")]),a._v(" "),e("li",[a._v("$% 当目标是函数库的时候，表示规则中的目标成员名，如果目标不是函数库文件，那么其值为空")]),a._v(" "),e("li",[a._v("$< 依赖文件集合中的第一个文件，而如果依赖文件使用了模式%,那其就是符合模式的一系列的文件集合。")]),a._v(" "),e("li",[a._v("$? 所有比目标新的依赖目标集合，以空格分开")]),a._v(" "),e("li",[a._v("$^ 所有依赖文件的集合，使用空格分开，会自动去重。")]),a._v(" "),e("li",[a._v("$+ 与前一个类似，但不会自动去重")]),a._v(" "),e("li",[a._v('$* 这个变量表示目标模式中“％”及其之前的部分，如果目标是 test/a.test.c,目标模式为a.%.c,那么"$*"就是test/a.test。')])]),a._v(" "),e("h2",{attrs:{id:"makefile-中的伪目标"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#makefile-中的伪目标"}},[a._v("#")]),a._v(" makefile 中的伪目标")]),a._v(" "),e("p",[a._v("一般来说，如何一个目标没有依赖，其命令又不会生成文件，那么这就被当作一个伪目标，即不会产生实际目标文件的目标。但是，如果目录下存在一个和目标相同名字的文件，那么make工具就不会将其视作一个伪目标，而又因为其没有依赖，使得make认为状态没有更新而不会执行命令。因此，一般情况可以加上"),e("code",[a._v(".PHONY")]),a._v("进行显示说明，这样，即使目录存在同名文件，也仍会执行命令。")])])}),[],!1,null,null,null);e.default=n.exports}}]);