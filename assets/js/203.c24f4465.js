(window.webpackJsonp=window.webpackJsonp||[]).push([[203],{517:function(v,_,t){"use strict";t.r(_);var l=t(8),e=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("create date: 2023-09-21 17:25"),_("br"),v._v("\nStatus: #idea"),_("br"),v._v("\nTags: [[算法]]")]),v._v(" "),_("hr"),v._v(" "),_("h1",{attrs:{id:"算法思想"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法思想"}},[v._v("#")]),v._v(" 算法思想")]),v._v(" "),_("h3",{attrs:{id:"设计一个算法的过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计一个算法的过程"}},[v._v("#")]),v._v(" 设计一个算法的过程")]),v._v(" "),_("ul",[_("li",[v._v("选择一个问题实例")]),v._v(" "),_("li",[v._v("写下解决该实例步骤\n"),_("ul",[_("li",[v._v("应该考虑能方便计算机执行：比如数字的方式对实例中的对象进行表示")]),v._v(" "),_("li",[v._v("伪代码是一个不错的方法")])])]),v._v(" "),_("li",[v._v("泛化解决方案\n"),_("ul",[_("li",[v._v("适用任何实例，需要考虑更多的情况，如边界条件")]),v._v(" "),_("li",[v._v("在测试后发现错误后返回步骤进行迭代")]),v._v(" "),_("li",[v._v("一些经验：\n"),_("ul",[_("li",[v._v("重复性的运算，可以考虑与程序中的循环相对应，如重复n次,可有"),_("code",[v._v("for(int i; i < n: i++)")])]),v._v(" "),_("li",[v._v("重复对运算中含有变化的输入，难以用简单的循环解决：用递归的思想")])])])])]),v._v(" "),_("li",[v._v("测试算法\n"),_("ul",[_("li",[v._v("考虑极端情况")]),v._v(" "),_("li",[v._v("测试案例能得到较大的算法步骤覆盖率")]),v._v(" "),_("li",[v._v("此时是手动测试，测试量较少，速度较慢，在转化代码后进行更大量的测试")]),v._v(" "),_("li")])]),v._v(" "),_("li",[v._v("转换为代码\n"),_("ul",[_("li",[v._v("声明函数，根据算法步骤写下注释")]),v._v(" "),_("li",[v._v("复杂的步骤\n"),_("ul",[_("li",[v._v("每当你的算法中有复杂的代码行——一些无法直接转换为几行代码的内容时——你应该调用另一个函数来执行该步骤的工作。在某些情况下，这个函数可能已经存在——要么是因为你（或你的编程团队的某个成员）已经编写了它，要么是因为它存在于标准C库（或你正在使用的其他库）中。在这种情况下，你可以调用现有的函数（可能需要阅读其文档以找到确切的参数），然后继续翻译算法的下一行。在其他情况下，可能没有现成的函数来实现你所需的功能。在这些情况下，你应该决定函数接受哪些参数，它的确切行为是什么，以及你想如何调用它。将这些信息写下来（可以是纸上，也可以是源代码的其他地方的注释），但不必担心现在定义函数。相反，只需调用你“将来将编写”的函数，并继续翻译算法的下一行。当你完成编写这个算法的代码后，你将实现刚刚调用的函数——这是一个独立的编程问题，因此你需要按照所有的步骤来完成它。")])])])])])]),v._v(" "),_("h3",{attrs:{id:"技巧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#技巧"}},[v._v("#")]),v._v(" 技巧")]),v._v(" "),_("ul",[_("li",[v._v("使用循环时,以一个对应需要重复运算的恒等元素作为起始：\n在进行求和运算进，一个重复的操作是"),_("code",[v._v("sum = sum + i")]),v._v("，在数学上，我们利用了0是加法恒等元素的事实——对于任何数N，0 + N = N。我们还要注意，在对列表中的项进行数学运算之前，以恒等元素作为答案的起点通常是一个好主意，因为列表可能是空的。通常，对于对一个空列表的数学运算，正确的答案是所执行操作的恒等元素。也就是说，一个空列表的数字之和为0，一个空列表的数字之积为1（乘法恒等元素）。现在我们重新排列了步骤，可以很好地进行推广。")])]),v._v(" "),_("h1",{attrs:{id:"references"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[v._v("#")]),v._v(" references")])])}),[],!1,null,null,null);_.default=e.exports}}]);