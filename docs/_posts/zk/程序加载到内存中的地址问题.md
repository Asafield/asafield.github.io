---
title: 程序加载到内存中的地址问题
date: 2023-12-19 15:02:44
permalink: /pages/c1160a/
sidebar: auto
categories:
  - zk
tags:
  - 
author: 
  name: asafield
  link: https://github.com/Asafield
---

create date: 2023-10-25 23:10  
Status: #idea  
Tags: [[操作系统]]

---

# 程序加载到内存中的地址问题
标准的可执行程序需要固定的地址


**Assistant**

**Poe**
对于标准的可执行程序，通常情况下并不需要固定的地址。可执行程序的加载和执行是由操作系统负责管理的，它们会根据系统的需求将可执行程序加载到内存中，并为其分配合适的地址空间。

在现代操作系统中，可执行程序一般被加载到虚拟内存空间中，而不是直接使用物理内存地址。虚拟内存提供了一种将程序的逻辑地址空间映射到物理内存的机制，使得程序可以在不同的计算机上运行，或者在同一台计算机的不同运行时环境中执行，而无需考虑具体的物理地址。

当可执行程序被加载到内存中时，操作系统会为其分配一块合适的虚拟地址空间，并将程序的指令和数据映射到这个地址空间中的对应位置。这样，即使每次加载程序时分配的虚拟地址不同，程序仍然能够正常运行，因为它们使用的是相对地址或虚拟地址，而不是固定的物理地址。

当然，也有一些特殊情况下需要固定的地址，比如某些嵌入式系统或硬件设备可能要求程序在特定的物理地址上运行。但这些情况属于特例，不是标准的可执行程序所遵循的规范。

那elf中的entry point address是什么


**Assistant**

**Poe**
在可执行和共享目标文件的 ELF（Executable and Linkable Format，可执行和可链接格式）头部中，有一个字段称为 "entry point address"，它指定了程序执行的起始点。

entry point address 是一个虚拟地址，表示程序在内存中开始执行的位置。当操作系统加载可执行文件时，它会将程序的代码和数据加载到内存中，并将指令流的控制转移到 entry point address 所指定的位置，从而开始执行程序。

在 ELF 文件的头部中，entry point address 被记录在程序头部表（Program Header Table）中的入口地址字段（Entry Point Address Field）。这个字段指定了 ELF 文件中的一个段（segment）作为程序执行的入口点。当操作系统将程序加载到内存中时，它会根据这个字段的值来确定程序的起始执行位置。

需要注意的是，entry point address 并不是一个固定的物理地址，而是一个虚拟地址。它在程序加载时会被映射到实际的物理地址上，因此可以在不同的环境和操作系统中执行同一个 ELF 文件而不需要修改其代码。

总而言之，entry point address 是 ELF 可执行文件中指定程序执行起始点的虚拟地址。它告诉操作系统在加载程序后应该从哪里开始执行代码。

--enable-default-pie


**Assistant**

**Poe**
--enable-default-pie 是一个编译器选项，用于在编译可执行程序时启用默认的位置独立可执行文件（Position Independent Executable，PIE）模式。

PIE 是一种安全增强机制，它使得可执行文件在加载和执行时更难受到攻击。当使用 --enable-default-pie 编译选项时，编译器会生成位置独立的可执行文件，这意味着程序的代码和数据不依赖于固定的内存地址，而是使用相对地址或虚拟地址。

使用 PIE 模式的好处是，它使得代码的加载地址在每次执行时都是随机的，增加了攻击者进行内存注入等攻击的难度。这种随机化的加载地址可以有效地减少针对可执行文件的攻击，如缓冲区溢出、ROP（Return-Oriented Programming）等。

需要注意的是，启用 --enable-default-pie 编译选项并不是强制要求生成 PIE 可执行文件，而是将 PIE 设置为默认的编译选项。开发者仍然可以选择在需要时禁用 PIE 模式，或使用其他编译选项进行更精细的控制。

总结来说，--enable-default-pie 是一个编译选项，用于在编译可执行程序时启用默认的位置独立可执行文件模式，以提高程序的安全性。

如果不使用pie，每次加载程序的内存地址就是固定的吗


**Assistant**

**Poe**
如果不使用位置独立可执行文件（non-PIE），每次加载程序的内存地址通常是固定的。在这种情况下，可执行文件的代码和数据会被加载到固定的内存地址，因此程序在每次执行时都会在相同的地址空间中运行。

当操作系统加载非PIE可执行文件时，它会将程序的代码段、数据段等部分加载到预定的内存地址。这些地址在编译和链接过程中已经确定，并在可执行文件的头部中进行了指定。因此，每次加载该可执行文件时，代码和数据将被映射到相同的固定地址上。

这种固定的内存地址使得非PIE可执行文件更容易受到一些针对特定地址的攻击，如代码注入、栈溢出等。攻击者可以根据可执行文件加载的固定地址来计算和构造特定的恶意代码，从而实施攻击。

相比之下，使用位置独立可执行文件（PIE）模式可以在每次加载时随机化可执行文件的内存地址，增加了攻击者进行内存攻击的难度。

需要注意的是，是否使用PIE取决于编译器选项和链接器设置。在某些情况下，即使未显式启用PIE，仍然可以通过其他方式实现地址随机化。因此，具体的行为可能会受到编译器、操作系统和链接器的影响。

那如果两个程序的entry point address相同会看样


**Assistant**

**Poe**
如果两个程序的 entry point address（入口地址）相同，它们将会在同一个地址上开始执行。然而，这并不意味着两个程序会发生冲突或产生不正确的结果。

当操作系统加载可执行程序时，它会为每个程序分配独立的虚拟地址空间。虚拟地址空间使得每个程序的内存使用相互隔离，因此具有相同的 entry point address 的程序可以在不同的虚拟地址空间中独立运行，而互不干扰。

每个程序在加载时都会被映射到不同的虚拟地址空间，包括代码段、数据段、堆和栈等。即使它们具有相同的 entry point address，它们在内存中的实际物理地址仍然是不同的，因为操作系统会为每个程序分配独立的物理内存页框。

因此，如果两个程序具有相同的 entry point address，它们仍然可以独立运行，彼此之间不会产生冲突。每个程序都会在自己的虚拟地址空间中执行，访问自己的内存和资源，而不会相互干扰。

需要注意的是，如果两个程序有共享的库依赖或使用了共享资源（如共享内存），则需要确保适当的同步和资源管理，以避免可能的冲突和竞争条件。但就 entry point address 本身而言，它不会导致程序之间的冲突。
# references