---
title: 寄存器级的开发
date: 2023-12-19 15:02:44
permalink: /pages/76b1ae/
sidebar: auto
categories:
  - zk
tags:
  - 
author: 
  name: asafield
  link: https://github.com/Asafield
---

create date: 2023-12-10 20:39  
Status: #idea  
Tags: [[嵌入式]]

---

# 寄存器级的开发
## 什么是寄存器编程
**芯片的组成**：由内核（cpu）与核外外设组成，ARM公司进行内核的设计，ST/TI/NXP组合上特定的外设形成一个单片机。
**总线：** 多根并行的线，各根线之间传输特定的数据，进行控制、数据传输、寻址等操作；
- 连接了内核与外设，stm32f4有8条主控总线，7条被控总线
![image.png](https://pic-1312640559.cos.ap-chengdu.myqcloud.com//img/20231014134542.png)

![image.png](https://pic-1312640559.cos.ap-chengdu.myqcloud.com//img/20231014134558.png)
各种解释：
ccm:在嵌入式系统使用的一个类似高速缓存的东西，靠近cpu的内存，具有低延迟、高带宽的特性，与cpu核心直接耦合。
- 内核总线 I总线、D总线、S总线分别连接flash、flash/sram、sram/fsmc/ahb，传输指令、数据以及与外设通信
- 在通用x86架构的计算机中，总线是可以分为地址总线、数据总线以及控制总线的，这些也称为系统总线
在stm32中对外设的工作方式的配置需要用到寄存器，例如使GPIO口输出高电平：
```c
*(unsigned int*)（0x4002 1414) = 0xFFFF；//其中的的地址是输出数据寄存器的地址
```
使用别名，也就是寄存器映射的方式：
```c
#define GPIOF_BASE 0x40021414
#define GPIOF_ODR *(unsigned int*)（GPIOF_BASE + 0x14)
GPIOF_ODR = 0xFF;
```
根据外设速度对不同，选用不同的四条总线相应总线的最低地址也就是基地址：

| 总线名称 | 总线基地址  | 相对外设基地址的偏移 |
| -------- | ----------- | -------------------- |
| APB1     | 0x4000 0000 | 0x0                  |
| APB2     | 0x4001 0000 | 0x0001 0000          |
| AHB1     | 0x4002 0000 | 0x0001 0000          |
| AHB2     | 0x5000 0000 | 0x0001 0000          |
| AHB1     | 0x6000 0000 | 已不属于片上外设     |
与之类似的，外设也有外设基地址，其为特定外设的首个地址，以GPIO基地址为例：

| 外设名称 | 外设基地址  | 相对AHB1总线的地址偏移 |
| -------- | ----------- | ---------------------- |
| GPIOA    | 0x4002 0000 | 0x0                    |
| GPIOB    | 0x4002 0400 | 0x0000 0400            |
| GPIOC    | 0x4002 0800 | 0x0000 0800            |
| GPIOD    | 0x4002 0C00 | 0x0000 0C00            |
| GPIOE    | 0x4002 1000 | 0x0000 1000            |
| GPIOF    | 0x4002 1400 | 0x0000 1400            |
| GPIOG    | 0x4002 1800 | 0x0000 1800            |
| GPIOH    | 0x4002 1C00 | 0x0000 1C00            |
外设的地址范围类分部的就是外设的寄存器，GPIOF外设的各种寄存器地址如下：

|寄存器名称|寄存器地址|相对GPIOB基址的偏移|
|---|---|---|
|GPIOF_MODER|0x4002 1400|0x00|
|GPIOF_OTYPER|0x4002 1404|0x04|
|GPIOF_OSPEEDR|0x4002 1408|0x08|
|GPIOF_PUPDR|0x4002 140C|0x0C|
|GPIOF_IDR|0x4002 1410|0x10|
|GPIOF_ODR|0x4002 1414|0x14|
|GPIOF_BSRR|0x4002 1418|0x18|
|GPIOF_LCKR|0x4002 141C|0x1C|
|GPIOF_AFRL|0x4002 1420|0x20|
|GPIOF_AFRH|0x4002 1424|0x24|
对于外设的寄存器说明需要参考《STM32F4xx参考手册》中具体章节的寄存器描述部分。
### 使用结构体对GPIO进行封装
为了避免重复定义相似的基地址，如不同GPIO口，引入了结构体进行封装：
```c
typedef unsigned int  uint32_t;
typedef unsigned short  uint16_t;

/* GPIO寄存器列表 */
typedef struct {
 uint32_t MODER;    /*GPIO模式寄存器             地址偏移: 0x00      */
 uint32_t OTYPER;   /*GPIO输出类型寄存器          地址偏移: 0x04      */
 uint32_t OSPEEDR;  /*GPIO输出速度寄存器          地址偏移: 0x08      */
 uint32_t PUPDR;    /*GPIO上拉/下拉寄存器         地址偏移: 0x0C      */
 uint32_t IDR;      /*GPIO输入数据寄存器          地址偏移: 0x10      */
 uint32_t ODR;      /*GPIO输出数据寄存器          地址偏移: 0x14      */
 uint16_t BSRRL;    /*GPIO置位/复位寄存器低16位部分 地址偏移: 0x18     */
 uint16_t BSRRH;    /*GPIO置位/复位寄存器高16位部分 地址偏移: 0x1A     */
 uint32_t LCKR;     /*GPIO配置锁定寄存器          地址偏移: 0x1C      */
 uint32_t AFR[2];   /*GPIO复用功能配置寄存器       地址偏移: 0x20-0x24  */
} GPIO_TypeDef;
```

注：[[C语言]] 结构体内变量的存储空间是连续的，其中32位的变量占用4个字节，16位的变量占用2个字节。这样，只需要定义外设的基地址，对应的寄存器的地址也会因为结构体的特性而自动对应上。
```C
/*使用GPIO_TypeDef把地址强制转换成指针*/
#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)

/*使用定义好的宏直接访问*/
/*访问GPIOF端口的寄存器*/
GPIOF->BSRRL = 0xFFFF;       //通过指针访问并修改GPIOF_BSRRL寄存器
GPIOF->MODER = 0xFFFFFFF;    //修改GPIOF_MODER寄存器
GPIOF->OTYPER =0xFFFFFFF;    //修改GPIOF_OTYPER寄存器

uint32_t temp;
temp = GPIOF->IDR;          //读取GPIOF_IDR寄存器的值到变量temp中

/*访问GPIOA端口的寄存器*/
GPIOA->BSRRL = 0xFFFF;       //通过指针访问并修改GPIOA_BSRRL寄存器
GPIOA->MODER = 0xFFFFFFF;    //修改GPIOA_MODER寄存器
GPIOA->OTYPER =0xFFFFFFF;    //修改GPIOA_OTYPER寄存器

//uint32_t temp;     //该变量前面已定义
temp = GPIOA->IDR;          //读取GPIOA_IDR寄存器的值到变量temp中
```

修改寄存器的位操作方法：
```c
 //对 bit2 清零
 a &= ~(1<<2);
 /* 对某几位进行赋值 */

 //假设 a = 1000 0011 b
 a |= (1<<2*2);
 //此时对清零后的第2组bit4、bit5设置成二进制数“01 b ”（也就是“01 b”左移4位）
 //即 a = 1001 0011 b，成功设置了第2组的值，其它组不变
```

# references
野火的教程