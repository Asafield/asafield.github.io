---
title: c++ primer 第一章 c++基础
date: 2023-12-19 15:02:44
permalink: /pages/4900d5/
sidebar: auto
categories:
  - zk
tags:
  - 
author: 
  name: asafield
  link: https://github.com/Asafield
---

create date: 2023-11-08 16:06  
Status: #idea  
Tags: [[c++]]

---

# c++ primer 第一章 c++基础
基本数据类型：
- 算术类型
- 空类型：不对应具体值，只在一些特殊的场合进行应用。
c++提供了几种字符类型。除char外其他用于扩展字符集。有wchar_t、char16_t、char32_t。
一个建议：
- 在算术表达式中不要使用char或bool,只有在存放字符或布尔值进才使用它们。因为类型char在一些机器上有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果需要使用一个不大的整数，那么明确指定它的类型是signed char 或者 unsigned char。.
- 当我们赋给无符号类型一个超出他表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。但当我们赋给有符号类型一个超出他表示范围的值时，结果是未定义的此时，程序可能继续工作，可能崩溃，也可能产生垃圾数据。
- 切勿滥用带符号类型和无符号类型，因为带符号类型会隐式转换为无符号类型。
- 整形字面值的表示方法：八进制：024
- -10并不是表示负数，只是对该字面值取负而已，相当于对一个变量取负，如-x。
- 字符串字面值的类型实际上是由常量字符构成的数组。编译器在每个字符的结尾处添加一个空字符（'\\0')，因此，字符串字面值的实际长度要比它的内容多1。
- 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就或以采取分开的方式。
- 有两类字符程序员不能直接使用：一类是不可打印的字符，如退格或其他控制字符，因为它们没有可视的图符。另一类是在c++语言中有特殊含义的字符。
- 泛化的转义序列，其形式是\\x后紧跟1个或多个十六进制数字，或者\\后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。参考c++ primer中p36页中的示例。如`\115`就是10进制的77号字符，对应于ascii码表中的`M`。
- 通过添加如表2.2所列的前缀和后缀，可以改变整型、浮点和字符型字面值的默认类型。
- ![image.png](https://pic-1312640559.cos.ap-chengdu.myqcloud.com//img/20231108213425.png)
- 在整型字面值后缀为`U`时，则该字面值属于无符号类型。
- `nullptr`是指针字面值。
- 为了支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。这也就是c++将声明和定义区分开来的原因。
- 如果想声明一个变量而非定义它，就在变量名添加关键字`extern`，而且不要显式地初始化变量：
```cpp
extern int i; //声明而非定义
int j; //声明并定义

```
- 变量能且只能被定义一次，但是可以被多次声明，默认情况下使用`int j`，实际是隐式添加了关键字extern的，但不同的是包含了定义操作，如果多个文件都有`int j`这个语句，就会报错，但如果是`extern int j`则不会。
- 静态类型：含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查，为了给编译器检查提供条件，就需要在使用前声明变量的类型。
- 用户定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。
- **定义在函数体外的标识符不能以下划线开头**。
## 复合类型
>基于其他类型定义的类型。例如引用和指针

- 一条声明语句由一个**基于数据类型**和紧随其后的一个**声明符**列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。
### 引用（这里指“左值引用”）
>声明符：&d，其中d是声明的变量名。

注：一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。所以不能以先声明，再绑定的方式，也不以重新绑定到另一个对象，因此引用必须初始化。
```cpp
int ival = 1024;
int &refVal = ival;
//int &refVal2; //报错：引用必须被初始化
```
- 引用即别名，并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。
- 因为引用本身不是一个对象，所以不能定义引用的引用。
- [ ] 引用的类型都和与之绑定的对象严格匹配。但有两种例外情况。[[#引用类型必须与其所想和他采访期间的类型一致的例外情况]]
### 指针

>声明符： \*d，其中d是变量名

- [ ] 指针类型指向的对象都要各它所指向的对象严格匹配
#### 指针值
指针的值（即地址）应属于下列4种状态之一：
- 指向一个对象
- 指向紧邻对象所占空间的下一个位置。类似duke的课程中提到的那样，`int * p = &i; p++`,此时就不能再对该指针进行访问操作了。
- 空指针，意味着指针没有指向任何对象
- 无效指针，也就是上述情况之外的其他值。试图拷贝或以其他方式访问无效指针的值都将引发错误
#### 空指针
`int * p1 = nullptr;`等价于`int * p1 = 0`；`int * p1 = NULL`;
`nullptr`是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。
- C语言中任何类型的指针都可以（隐式地）转换为`void *`型，反过来也行；而c++中`void *` 不能隐式地转换为别的类型指针，可以将其它类型的指针赋给`void *`类型。这与`nullptr`有所不同。
- 任何非0指针（非空指针）对应的条件值都是true。可以用于条件判断。
- 不能直接操作`void *`类型的指针所指向的对象。
#### const
- const对象默认情况下仅在单个文件内有效，除非使用extern关键字
- const对象必须初始化，例如`const int i = 2`。
- 常量引用：指向一个常量对象的引用也只能是一个常量引用，例如：
```cpp
const int ci = 1024;
const int &ri = ci;
```
##### 引用类型必须与其所想和他采访期间的类型一致的例外情况
- 在初始化常量下合同纠纷允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：
```cpp
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2;
```
但这种是不行的：`int r4 = r1 * 2;`,非常量引用不能指向一个常量对象上。编译器会在一个常量引用指向不同类型对象进行初始化的时候创建一个未命名的对象，称为临时量对象。但如果该引用并非常量引用时，则是非法的，因为临时量的存在使得通过非常量引用来修改原对象的值。
### 指针和const
指常量的指针不能用于变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：
[const与指针](const与指针.md)  对应书中的顶层const与底层const的内容。用于声明引用的const都是底层const。
```cpp
const double pi = 3.14;
double * ptr = &pi;//error
const double * cptr = &pi;//correct
* cptr =42 // error
```

### constexpr 和常量表达式
- 字面值 
- 用常量表达式初始化的const对象也是常量表达式
- 在运行时才能获得值的表达式（如函数）并非常量表达式。
在C++11新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：
```cpp
constexpr int mf = 20;
constexpr int limit = mf + 1;
constexpr int sz =size();//只有当size是一个constexpr函数时才是一条正确的声明语句
```
#### 字面值类型
常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见，容易得到，就把它们称为“字面值类型”。
![image.png](https://pic-1312640559.cos.ap-chengdu.myqcloud.com//img/20231114161055.png)
#### 与const区分
- constexpr除了会在编译时检测是否为常量表达式之外， 还会在应用在指针上有所不同：
```cpp
const int * p = nullptr; //p 是一个指向整形常量的指针
constexpr int *q = nullptr;//p是一个指向整数的常量指针,相当于顶层const
```

# references