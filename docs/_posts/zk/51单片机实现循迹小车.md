---
title: 51单片机实现循迹小车
date: 2023-12-19 15:02:44
permalink: /pages/8cce86/
sidebar: auto
categories:
  - zk
tags:
  - 
author: 
  name: asafield
  link: https://github.com/Asafield
---
create date: 2022-12-11 19:29
modify date: 2022-12-19 14:18
Status: #notes #project
Tags: [[单片机]] [[循迹]]    

---

#  51单片机实现循迹小车

# references
## 硬件设计
循迹小车的硬件设计主要涉及的是小车的组装和对应线路的连接。
1. 小车的组装相对简单，最后的实物大致如下所示：
![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211193435.png)
其中需要说明的是，本次实验只要求实现循迹功能，因此并未使用到下面的红外避障模块，可以不用装上。
![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211194824.png)

2. 下面是线路连接说明
![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/imgSnipaste_2022-12-11_20-03-59.png)
如上图所示，共有8处连线需要注意：
- `1`为电源输入，与电池盒的输出线相连；
- `2`为电源输出，`3`为驱动板输入，两者需要相连，注意红线为`VCC`，黑线为`GND`，不要接反了；
- `4`为单片机IO口引脚，`5`为驱动板的`IN1`到`IN4`以及`ENA`和`ENB`，按照器件上的标注对应连接即可。
- `6`为与循迹模块的对应接口，按照器件上的标注对应连接即可。
- `7`和`8`为驱动板与两个电机之间的连线，按照上图所示连接即可。
到这里，基本完成了小车的硬件组装与线路连接，小车要完成循迹进行这些连线就够了，不过在烧录程序到单片机中时还需要额外的连线，这个将在后面进行说明。
## 软件设计
下面进行程序的软件设计，前面的实验原理中说明了小车循迹的大致原理，可以依此完成软件的设计。软件流程图如下：
![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211204948.png)
可以发现，循迹的流程是相当简单的，只需要根据红外循迹传感模块的检测结果对左右电机进行相对应的控制即可。那循迹的功能就可以对应地分解：
- 分析红外循迹模块的数据
- 控制两个电机
### (1)分析红外循迹模块的数据
实验原理部分介绍了红外循迹模块，其包含了左右两个传感器模块，在前面的连线部分可以发现，单片机的引脚`P34`接到了红外模块的左传感器，引脚`P35`接到了右传感器（**注意：这里的左右参考的标准是前面的硬件设计的实物图，在安装是与传感器上的标注是相反的**）。传感器检测到黑线会输出高电平（`1`），未检测到会输出低电平（`0`）。有：

| 小车状态 | 左传感器输出 | 右传感器输出 | 执行操作 |
| -------- | ------------ | ------------ | -------- |
| 正常行进 | 1            | 1            | 前进     |
| 左边出线 | 0            | 1            | 右转     |
| 右边出线 | 1            | 0            | 左转     |
| 左右出线 | 0            | 0            | 停止     |
还需注意，红外传感器，可能需要校准，校准的旋钮在之前实验原理部分给出的模块图上有标注，校准后将小车放到黑线上会发现循迹模块上指示灯亮，移开到没有黑线上时指示灯灭。请确保你的红外循迹模块完成校准。
相关程序如下：
```c
sbit leftSensor = P3^4;//左传感器 为0 没有识别到黑线 为1识别到黑线
sbit rightSensor = P3^5;//右传感器	为0 没有识别到黑线 为1识别到黑线
void Tracking()
{
	//为0 没有识别到黑线 为1识别到黑线
	char data1,data2 = leftSensor,data3 = rightSensor;
	data1 = data2*10+data3;
	if(data1 == 11)//在黑线上，前进
	{
		//forward(120,120);//前进
		forward(70,70);//前进
	}
	else
	{
	 	if(data1 == 10)//小幅偏右，左转
		{
			//left_run(80,160);//左转
			left_run(70,70);//左转
		}
		if(data1 == 1)//小幅偏左，右转
		{
			//right_run(160,80);//右转
			right_run(70,70);//右转
		}
		if(data1 == 0)//大幅偏左或偏右，已脱离轨道
		{
			stop();	
		}
	}
}
```
### (2)控制两个电机

>上面的程序中针对不同的结果，需要控制两个电机进行对应的操作，不过上面只给出封装好的函数，下面实现这些函数

驱动电机需要控制驱动板进行合适的输出，L298N电机驱动板的原理和使用在前面的实验原理部分已经进行了说明，总结如下：

| ENA | IN1 | IN2 | 左电机 | ENB | IN3 | IN4 | 右电机 |
| --- | --- | --- | ------ | --- | --- | --- | ------ |
| 0   | x   | x   | 停止   | 0   | x   | x   | 停止   |
| 1   | 0   | 0   | 停止   | 1   | 0   | 0   | 停止   |
| 1   | 1   | 0   | 正转   | 1   | 1   | 0   | 反转   |
| 1   | 0   | 1   | 反转   | 1   | 0   | 1   | 正转   |
| 1   | 1   | 1   | 停止   | 1   | 1   | 1   | 停止       |
下面分别来讨论` L298N`驱动板的几个引脚：
- `IN1`-到`IN4`:
    用来控制小车的转向，控制是左右电机转向即可实现小车的转向，例如：
    要实现左转，只要左电机正转，右电机反转。
- `ENA`与`ENB`:
	这两个引脚会接收`PWM`波用来控制转速，占空比越大，转速越快。
	在51单片机中是通过定时器实现的，关于51单片机的定时器的使用，大家可以自行查阅相关用法。其产生占空比为`x`的`PWM`波的原理如下：
	通过配置定时器可以设置计数器按照一定周期进行计数，例如：
	- `100us`计数加一，计数到200重新开始计数，相当于周期为`20ms`
	- 计数值小于等于`x`时，对应引脚为高电平；大于`x`则输出低电平。
	如下图所示：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211223035.png)
```C
unsigned char	pwm_val_left,pwm_val_right;	//中间变量，用户请勿修改。
unsigned char 	pwm_left,pwm_right;			//定义PWM输出高电平的时间的变量。用户操作PWM的变量。
sbit leftMotorPwm = P1^5; //为1 左电机使能
sbit IN1 = P1^4; //为1 左电机正转
sbit IN2 = P1^3; //为1 左电机反转
sbit IN3 = P1^2; //为1 右电机反转
sbit IN4 = P1^1; //为1 右电机正转
sbit rightMotorPwm = P1^0; //为1 右电机使能

void forward(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 0;
	IN4 = 1;
}

void left_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 1;
	IN4 = 0;
}

void right_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 0;
	IN2 = 1;
	IN3 = 0;
	IN4 = 1;
}

void stop(void)
{
	IN1 = 0;
	IN2 = 0;
	IN3 = 0;
	IN4 = 0;
}
//***************定时器与PWM相关配置***********************

/**** Timer0初始化****/
void Timer0_Init(void)
{
	TMOD |= 0x02;//定时器0，8位自动重装模块
	TH0 = 164;
	TL0 = 164;//11.0592M晶振，12T溢出时间约等于100微秒
	TR0 = 1;//启动定时器0
	ET0 = 1;//允许定时器0中断
	EA	= 1;//总中断允许	
}
 
/***** Timer0中断函数****/
void timer0_int (void) interrupt 1
{
	pwm_val_left++;
	pwm_val_right++;
	if(pwm_val_left<=pwm_left)		leftMotorPwm = 1;  //装载左PWM输出高电平时间
	else leftMotorPwm = 0; 						    //装载左PWM输出低电平时间
	if(pwm_val_left>=PWM_DUTY)		pwm_val_left = 0;	//如果左对比值大于等于最大占空比数据，则为零

	if(pwm_val_right<=pwm_right)	rightMotorPwm = 1; //装载右PWM输出高电平时间
	else rightMotorPwm = 0; 							//装载右PWM输出低电平时间
	if(pwm_val_right>=PWM_DUTY)		pwm_val_right = 0;	//如果右对比值大于等于最大占空比数据，则为零
}	
```
这样，就完成了各个模块中软件设计
### 最终程序与烧录方式
综合以上，最终程序如下：
```c
#include <reg52.h>//51头文件

unsigned char	pwm_val_left,pwm_val_right;	//中间变量，用户请勿修改。
unsigned char 	pwm_left,pwm_right;			//定义PWM输出高电平的时间的变量。用户操作PWM的变量。

#define		PWM_DUTY		100			//定义PWM的周期，数值为定时器0溢出周期，假如定时器溢出时间为100us，则PWM周期为10ms。
#define		PWM_HIGH_MIN	35			//限制PWM输出的最小占空比。用户请勿修改。
#define		PWM_HIGH_MAX	PWM_DUTY	//限制PWM输出的最大占空比。用户请勿修改。


/*电机驱动IO定义*/
sbit leftMotorPwm = P1^5; //为1 左电机使能
sbit IN1 = P1^4; //为1 左电机正转
sbit IN2 = P1^3; //为1 左电机反转
sbit IN3 = P1^2; //为1 右电机反转
sbit IN4 = P1^1; //为1 右电机正转
sbit rightMotorPwm = P1^0; //为1 右电机使能

sbit leftSensor = P3^4;//左传感器 为0 没有识别到黑线 为1识别到黑线
sbit rightSensor = P3^5;//右传感器	为0 没有识别到黑线 为1识别到黑线

void Timer0_Init(void); //定时器0初始化
void LoadPWM(void);//装入PWM输出值 
void forward(unsigned char LeftSpeed,unsigned char RightSpeed);//QX_A11智能小车前进 
void left_run(unsigned char LeftSpeed,unsigned char RightSpeed);//QX_A11智能小车左转  
void right_run(unsigned char LeftSpeed,unsigned char RightSpeed);//QX_A11智能小车右转
void stop(void);//QX_A11智能小车停车

void Tracking()
{
	//为0 没有识别到黑线 为1识别到黑线
	char data1,data2 = leftSensor,data3 = rightSensor;
	data1 = data2*10+data3;
	if(data1 == 11)//在黑线上，前进
	{
		//forward(120,120);//前进
		forward(70,70);//前进
	}
	else
	{
	 	if(data1 == 10)//小幅偏右，左转
		{
			//left_run(80,160);//左转
			left_run(70,70);//左转
		}
		if(data1 == 1)//小幅偏左，右转
		{
			//right_run(160,80);//右转
			right_run(70,70);//右转
		}
		if(data1 == 0)//大幅偏左或偏右，已脱离轨道
		{
			stop();	
		}
	}
}

/*主函数*/     
void main(void)
{
	Timer0_Init();//定时0初始化
	while(1)
	{
		Tracking();
	}	
}



void forward(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 0;
	IN4 = 1;
}

void left_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 1;
	IN4 = 0;
}

void right_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 0;
	IN2 = 1;
	IN3 = 0;
	IN4 = 1;
}

void stop(void)
{
	IN1 = 0;
	IN2 = 1;
	IN3 = 1;
	IN4 = 0;
}

/********************* Timer0初始化************************/
void Timer0_Init(void)
{
	TMOD |= 0x02;//定时器0，8位自动重装模块
	TH0 = 164;
	TL0 = 164;//11.0592M晶振，12T溢出时间约等于100微秒
	TR0 = 1;//启动定时器0
	ET0 = 1;//允许定时器0中断
	EA	= 1;//总中断允许	
}
 
/********************* Timer0中断函数************************/
void timer0_int (void) interrupt 1
{
	pwm_val_left++;
	pwm_val_right++;
	if(pwm_left > PWM_HIGH_MAX)		pwm_left = PWM_HIGH_MAX;	//如果左输出写入大于最大占空比数据，则强制为最大占空比。
	if(pwm_left < PWM_HIGH_MIN)		pwm_left = PWM_HIGH_MIN;	//如果左输出写入小于最小占空比数据，则强制为最小占空比。
	if(pwm_right > PWM_HIGH_MAX)	pwm_right = PWM_HIGH_MAX;	//如果右输出写入大于最大占空比数据，则强制为最大占空比。
	if(pwm_right < PWM_HIGH_MIN)	pwm_right = PWM_HIGH_MIN;	//如果右输出写入小于最小占空比数据，则强制为最小占空比。
	
	if(pwm_val_left<=pwm_left)		leftMotorPwm = 1;  //装载左PWM输出高电平时间
	else leftMotorPwm = 0; 						    //装载左PWM输出低电平时间
	if(pwm_val_left>=PWM_DUTY)		pwm_val_left = 0;	//如果左对比值大于等于最大占空比数据，则为零

	if(pwm_val_right<=pwm_right)	rightMotorPwm = 1; //装载右PWM输出高电平时间
	else rightMotorPwm = 0; 							//装载右PWM输出低电平时间
	if(pwm_val_right>=PWM_DUTY)		pwm_val_right = 0;	//如果右对比值大于等于最大占空比数据，则为零
}	

```

**烧录到小车方式**
1. 编译生成hex格式的文件，这也就是需要烧录到小车的文件，注意编译前需要在软件设置：
	首先点击这里：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211233944.png)
	接着：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211234235.png)然后编译：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211234324.png)
	可以发现，编译后生成了hex文件，记住这个文件的位置：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211234510.png)
1. 烧录到小车：
	首先小车的开发板上接上串口烧录模块：注意这里，只接三根即可，其中`RXD`接另一边的`TXD`，`TXD`接另一边的`RXD`，最后一根为`GND`对应相接即可。
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211235459.png)
	然后打开`STC-ISP`软件，选择芯片型号：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212000327.png)
	接着打开程序文件，选择之前生成的`hex`文件，其位置一般在编译后会在工程目录下的`Object`文件夹下。
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212001002.png)
	选择合适的扫描串口，这里在小车通过烧录模块与电脑连接后进行，需要选择带有`CH340`字样的端口，端口号可能与这里不一样：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212001514.png)
	硬件选项如下：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212001807.png)
	最后点击下载，点击之前确认小车开发板上的电源已经关闭了，点击后再打开电源，看到操作成功字样代表烧录完成：
	![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212002627.png)
至此，就完成了以51单片机为主控循迹小车的设计，现在可以将小车放在黑线上试一试了。


