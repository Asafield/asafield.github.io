---
title: c语言中的数组
date: 2023-12-19 15:02:44
permalink: /pages/269be2/
sidebar: auto
categories:
  - zk
tags:
  - 
author: 
  name: asafield
  link: https://github.com/Asafield
---

create date: 2023-10-31 17:13  
Status: #idea  
Tags: [[c语言]]

---

# c语言中的数组
在对数组进行索引时，有：`array1[i]`与`*(array1 + i)`是等价的：
- 数组变量名指向的是首个元素的地址，但不能作为lvalue被修改，可以用`array1[i]`的方式进行修改与访问
- 两者等价的原因是因为前者会自动被解算为后者

# c语言中的数组的复制
- str1 = str2这种格式会直接复制指针，结果是两个数组指向同一个内存空间
- 常用的c标准库与区别：
	- strncpy，将n个字符从源字符数组复制到目标数组，当n小于源数组时，不会复制`\0`字符串的结尾标志，就会在应用时导致难以预知的问题
	- strcpy，更加危险，因为没有指定复制的个数的话，就会导致可能对超出数组边界的内存空间进行操作。
	- strdup，会为复制的字符串分配空间，将其复制进去。这涉及动态分配的相关知识。
- [x] 既然有`sizeof(arr)/sizeof(int)`这种方式，那又为什么不在复制字符串的时候对源数组和目标数组进行判断呢？ ✅ 2023-12-05
>请注意，这只适用于静态数组，对于指向动态分配内存的指针，该方法无效。

## 为什么在了函数外可以通过这种方式计算数组长度，而在函数内就不行:
在函数外部，如果你声明一个静态数组，并使用sizeof运算符计算其大小，那么会得到正确的结果。这是因为在函数外部声明的静态数组具有静态存储期，编译器可以在编译时确定其大小。

例如，以下代码在函数外部声明了一个静态数组：
```c
char str[] = "Hello";
size_t length = sizeof(str) / sizeof(str[0]);
```

在这种情况下，sizeof(str)将返回整个数组的大小，而sizeof(str[0])将返回单个元素的大小。因此，通过将它们相除，你可以得到正确的数组元素数量。

然而，在函数内部，当你将一个数组作为函数参数传递时，它将被隐式地转换为指向其第一个元素的指针。由于指针类型的大小与指针指向的数据类型无关，所以在函数内部使用sizeof来计算指针类型的大小是不正确的，因为它不会返回整个数组的大小。

因此，在函数内部使用sizeof运算符来计算数组的大小将导致错误的结果。为了正确计算数组的元素数量，你需要将数组的长度作为额外的参数传递给函数。
# c语言中将字符串转换为int类型的数字
## 库函数
- atoi函数
- strtol函数
## 多维数组与指针数组
### 多维数组：
int marray\[4]\[3]
![image.png](https://pic-1312640559.cos.ap-chengdu.myqcloud.com//img/20231206152203.png)


### 指针数组：
```c
double row0[3];

double row1[3];

double row2[3];

double row3[3];

double * myMatrix[4] = {row0, row1, row2, row3};
```
![image.png](https://pic-1312640559.cos.ap-chengdu.myqcloud.com//img/20231206152149.png)
在上图中，我们又有了一个 4x3 矩阵，不过，这个矩阵在内存中的表示方式相当不同。在这里，\_myMatrix_是由 4 个指针组成的数组，这些指针明确指向矩阵的行数组。左图描述了该数据结构的概念：\_myMatrix_是一个由 4 个指针组成的数组，每个指针都指向_row0-row3_ 数组中的一行。图的右侧描述了该数据结构的内存布局。在这里，每个行数组在内存中不一定相邻（可能相邻，但不一定）。现在， _myMatrix_的四个条目中包含指向四个行数组（地址）的指针。

两种表示方法访问数组元素的方式类似。在两种表示法中，_myMatrix__[2_] 的值都是指向矩阵第二行数组的指针。同样，_myMatrix_[_2_] 的值是指向矩阵第二行第一列**double**的指针。

然而，这两者之间有一些明显的不同。首先，在这个指针数组表示法中，指向行的指针明确存储在内存中。因此，计算_myMatrix_ _[i_] 实际上需要从内存中读取一个值，而不仅仅是计算偏移量。这种差异对性能有影响，我们在此不做讨论，因为我们不准备讨论性能问题（这种讨论需要详细的硬件知识）。

明确存储指向矩阵行的指针可以让我们用这种表示法做一些第一种表示法做不到的事情。首先，我们不必受限于每行的大小必须与其他行相同。其次，在指针数组表示法中，_myMatrix_ _[i_] 是一个 l 值（回想一下，如果我们只声明一个多维数组，它就不是 l 值）。因此，我们可以根据需要改变指针的指向。第三，我们可以让两行指向完全相同的数组（相互别名）。虽然这些能力对于数学矩阵来说可能用处不大，但对于其他各种拥有多维数据的任务来说，它们却非常有用。当我们学习动态分配时，这种指针数组表示法也将被证明非常有用。

## 使用陷阱
```c
#include "stdio.h"
#include "string.h"
#include "stddef.h"
#include "stdlib.h"
int main(){
  int arr1[3][2] = {{1,2},{3,4},{5,6}};
  int arr21[2] = {7,8};
  int arr22[2] = {9,10};
  int arr23[2] = {11,12};
  int* arr2[3] = {arr21,arr22,arr23};
  int ** arr3 = (int **)arr1;

  printf("%d\n",arr1[2][1]);
  printf("%d\n",arr2[2][1]);
  printf("%d\n",arr3[2][1]);
  return 0;
}
```
上述代码中`  int ** arr3 = (int **)arr1;`使用了多重指针对数组进行了转换，最后在依照数组的方式进行寻址`  printf("%d\n",arr3[2][1]);`时就会出现错误。这是因为arr3\[2]\[1]会先寻址到`arr3[2]`该位置是存储的原数组中的元素，是一个值而非指针，当进行更进一步的寻址时就会出现错误。这也是在函数中的参数有多维数组时需要注意的地方。`int **`类型的的参数只能接受指针数组，而不能使用接受原始的多维数组作为参数，这里可以使用`arr[][2]`作为参数。
# references
[sizeof获取数组长度_sizeof 求数组长度-CSDN博客](https://blog.csdn.net/u011852211/article/details/52743637)
[指针数组 | Coursera](https://www.coursera.org/learn/pointers-arrays-recursion/supplement/IpCYm/array-of-pointers)