---
title: 实验指导书
date: 2023-12-19 15:02:44
permalink: /pages/861a22/
sidebar: auto
categories:
  - zk
tags:
  - 
author: 
  name: asafield
  link: https://github.com/Asafield
---
create date: 2022-12-11 19:29
Status: #notes #project
Tags: [[单片机]] 

---

# 1 实验目的
1. 熟悉软件的使用
2. 熟悉嵌入式开发与FPGA开发的不同
3. 理解循迹小车的软硬件实现原理
4. 实物复现并验证两种方式来实现循迹小车

# 2 实验内容

1. 利用51单片机作为控制器实现循迹小车：
   元器件 ： 
   - 使用控制板芯片：STC89C52
   - 其它： 
      - 电源：1.5V干电池 4节
      - L298N电机驱动板 1个
      - 红外循迹模块
      - 直流电机 两个
      - 小车底板、轮子、铜柱、镙母 若干
      要求：
   - 在白色或浅色地面上贴黑色胶带，胶带宽度贴 3cm，最后小车能够沿着所贴的胶带轨迹行进。
2. 利用FPGA开发板作为控制器实现循迹小车：
   元器件： 
   - 使用控制板芯片：CycloneII EP2C5T144
   - 其它： 
      - 电源：1.5V干电池 4节
      - L298N电机驱动板 1个
      - 红外循迹模块
      - 直流电机 两个
      - 小车底板、轮子、铜柱、镙母 若干
      要求：
   - 在白色或浅色地面上贴黑色胶带，胶带宽度贴 3cm，最后小车能够沿着所贴的胶带轨迹行进。

# 3 实验原理

## 3.1 总体结构

![|600](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211163200.png#crop=0&crop=0&crop=1&crop=1&id=ltlIj&originHeight=775&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

小车的结构如上图所示，除开供电模块外主要由红外循迹模块、主控模块、电机驱动模块、两个直流电机与对应的左右轮组成。主要的工作流程如下：

- 红外循迹模块能够对模块下方的黑线进行检测，将检测结果返回给主控
- 主控根据结果判断是否向左或右偏离了黑线，根据不同的情况，向L298N驱动模块输出不同的控制信号与PWM信号。
- L298N电机驱动模块根据控制信号来决定驱动直流电机的电压的正负，根据PWM的占空比来控制电压的大小。
- 电压的正负决定了轮子旋转的方向，PWM的占空比决定了轮子的转速
经过了以上的流程，就实现了根据红外循迹模块的数据来控制左右轮转向与转速的效果。下面对红外循迹模块与L298N驱动模块的原理与使用方式进行介绍。

## 3.2 红外循迹模块


![|475](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211165246.png#crop=0&crop=0&crop=1&crop=1&id=DrLUd&originHeight=590&originWidth=777&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

循迹传感器的型号为TCRT5000，具体的参数大家可能在网上查询数据手册得到。
**原理：** 传感器的红外发射二极管不断发射红外线，当发射出的红外线没有被反射回来或被反射回来但强度不够大时，红外接收管一直处于关断状态，此时模块的输出端为高电平，指示二极管一直处于熄灭状态；被检测物体出现在检测范围内时，红外线被反射回来且强度足够大，红外接收管饱和，此时模块的输出端为低电平，指示二极管被点亮。

## 3.3 L298N电机驱动模块


![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211174148.png#crop=0&crop=0&crop=1&crop=1&id=S5Y9d&originHeight=637&originWidth=659&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

该电机驱动模块本质上是一个双H桥电路，其具体的工作原理可能参考这篇文章：
[【电机驱动芯片（H桥、直流电机驱动方式）——DRV8833、TB6612、A4950、L298N的详解与比较】](https://blog.csdn.net/qq_44897194/article/details/105524808)
本次实验我们主要关注模块的使用方式：

| ENA | IN1 | IN2 | 左电机 | ENB | IN3 | IN4 | 右电机 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | x | x | 停止 | 0 | x | x | 停止 |
| 1 | 0 | 0 | 停止 | 1 | 0 | 0 | 停止 |
| 1 | 1 | 0 | 正转 | 1 | 1 | 0 | 反转 |
| 1 | 0 | 1 | 反转 | 1 | 0 | 1 | 正转 |
| 1 | 1 | 1 | 停止 | 1 | 1 | 1 | 停止 |


注：上表的情况对应了实际接线情况为：

| 左电机黑线 | 左电机红线 | 右电机黑线 | 右电机红线 |
| --- | --- | --- | --- |
| OUT1 | OUT2 | OUT3 | OUT4 |

第一个表描述了如何控制电机的方向，也即是通过控制`IN1`、`IN2`、`IN3`、`IN4`来实现。而对速度的控制则是通过`PWM`波对`ENA`与`ENB`进行控制，`PWM`的占空比对应了电机的转速。对于`PWM`的解释可能参考下面这篇文章：
[理解PWM](https://zhuanlan.zhihu.com/p/374083276)
经过上面的描述，我们对循迹小车的结构和大致原理有了一个大致，下面，分别用两种主控（51单片机与FPGA）来进行循迹小车的软硬件设计。

# 4 51单片机实现循迹小车

## 4.1 硬件设计
循迹小车的硬件设计主要涉及的是小车的组装和对应线路的连接。

1.  小车的组装相对简单，最后的实物大致如下所示：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211193435.png#crop=0&crop=0&crop=1&crop=1&id=G9kvB&originHeight=804&originWidth=945&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

其中需要说明的是，本次实验只要求实现循迹功能，因此并未使用到下面的红外避障模块，可以不用装上。

![](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211194824.png#crop=0&crop=0&crop=1&crop=1&id=HubN6&originHeight=187&originWidth=268&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 

2.  下面是线路连接说明

![||475](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/imgSnipaste_2022-12-11_20-03-59.png#crop=0&crop=0&crop=1&crop=1&id=ejS6v&originHeight=1290&originWidth=1720&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

如上图所示，共有8处连线需要注意： 
- `1`为电源输入，与电池盒的输出线相连；
- `2`为电源输出，`3`为驱动板输入，两者需要相连，注意红线为`VCC`，黑线为`GND`，不要接反了；
- `4`为单片机IO口引脚，`5`为驱动板的`IN1`到`IN4`以及`ENA`和`ENB`，按照器件上的标注对应连接即可。
- `6`为与循迹模块的对应接口，按照器件上的标注对应连接即可。
- `7`和`8`为驱动板与两个电机之间的连线，按照上图所示连接即可。
到这里，基本完成了小车的硬件组装与线路连接，小车要完成循迹进行这些连线就够了，不过在烧录程序到单片机中时还需要额外的连线，这个将在后面进行说明。

## 4.2 软件设计
下面进行程序的软件设计，前面的实验原理中说明了小车循迹的大致原理，可以依此完成软件的设计。软件流程图如下：

<img src="https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211204948.png#crop=0&crop=0&crop=1&crop=1&id=K0ZVw&originHeight=1028&originWidth=666&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)" width="450"/>

可以发现，循迹的流程是相当简单的，只需要根据红外循迹传感模块的检测结果对左右电机进行相对应的控制即可。那循迹的功能就可以对应地分解：

- 分析红外循迹模块的数据
- 控制两个电机

### 4.2.1 分析红外循迹模块的数据
实验原理部分介绍了红外循迹模块，其包含了左右两个传感器模块，在前面的连线部分可以发现，单片机的引脚`P34`接到了红外模块的左传感器，引脚`P35`接到了右传感器（**注意：这里的左右参考的标准是前面的硬件设计的实物图，在安装时与传感器上的标注是相反的**）。传感器检测到黑线会输出高电平（`1`），未检测到会输出低电平（`0`）。有：

| 小车状态 | 左传感器输出 | 右传感器输出 | 执行操作 |
| --- | --- | --- | --- |
| 正常行进 | 1 | 1 | 前进 |
| 左边出线 | 0 | 1 | 右转 |
| 右边出线 | 1 | 0 | 左转 |
| 左右出线 | 0 | 0 | 停止 |

还需注意，红外传感器，可能需要校准，校准的旋钮在之前实验原理部分给出的模块图上有标注，校准后将小车放到黑线上会发现循迹模块上指示灯亮，移开到没有黑线上时指示灯灭。请确保你的红外循迹模块完成校准。
相关程序如下：
```c
sbit leftSensor = P3^4;//左传感器 为0 没有识别到黑线 为1识别到黑线
sbit rightSensor = P3^5;//右传感器	为0 没有识别到黑线 为1识别到黑线
void Tracking()
{
	//为0 没有识别到黑线 为1识别到黑线
	char data1,data2 = leftSensor,data3 = rightSensor;
	data1 = data2*10+data3;
	if(data1 == 11)//在黑线上，前进
	{
		//forward(120,120);//前进
		forward(70,70);//前进
	}
	else
	{
	 	if(data1 == 10)//小幅偏右，左转
		{
			//left_run(80,160);//左转
			left_run(70,70);//左转
		}
		if(data1 == 1)//小幅偏左，右转
		{
			//right_run(160,80);//右转
			right_run(70,70);//右转
		}
		if(data1 == 0)//大幅偏左或偏右，已脱离轨道
		{
			stop();	
		}
	}
}
```

### 4.2.2 控制两个电机
> 上面的程序中针对不同的结果，需要控制两个电机进行对应的操作，不过上面只给出封装好的函数，下面实现这些函数

驱动电机需要控制驱动板进行合适的输出，L298N电机驱动板的原理和使用在前面的实验原理部分已经进行了说明，总结如下：

| ENA | IN1 | IN2 | 左电机 | ENB | IN3 | IN4 | 右电机 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | x | x | 停止 | 0 | x | x | 停止 |
| 1 | 0 | 0 | 停止 | 1 | 0 | 0 | 停止 |
| 1 | 1 | 0 | 正转 | 1 | 1 | 0 | 反转 |
| 1 | 0 | 1 | 反转 | 1 | 0 | 1 | 正转 |
| 1 | 1 | 1 | 停止 | 1 | 1 | 1 | 停止 |

下面分别来讨论`L298N`驱动板的几个引脚：

- `IN1`-到`IN4`:
用来控制小车的转向，控制是左右电机转向即可实现小车的转向，例如：
要实现左转，只要左电机反转，右电机正转。
- `ENA`与`ENB`:
这两个引脚会接收`PWM`波用来控制转速，占空比越大，转速越快。
在51单片机中是通过定时器实现的，关于51单片机的定时器的使用，大家可以自行查阅相关用法。其产生占空比为`x`的`PWM`波的原理如下：
通过配置定时器可以设置计数器按照一定周期进行计数，例如： 
   - `100us`计数加一，计数到200重新开始计数，相当于周期为`20ms`
   - 计数值小于等于`x`时，对应引脚为高电平；大于`x`则输出低电平。
如下图所示：
![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211223035.png#crop=0&crop=0&crop=1&crop=1&id=BqS4z&originHeight=934&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

```c
unsigned char	pwm_val_left,pwm_val_right;	//中间变量，用户请勿修改。
unsigned char 	pwm_left,pwm_right;			//定义PWM输出高电平的时间的变量。用户操作PWM的变量。
sbit leftMotorPwm = P1^5; //为1 左电机使能
sbit IN1 = P1^4; //为1 左电机正转
sbit IN2 = P1^3; //为1 左电机反转
sbit IN3 = P1^2; //为1 右电机反转
sbit IN4 = P1^1; //为1 右电机正转
sbit rightMotorPwm = P1^0; //为1 右电机使能

void forward(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 0;
	IN4 = 1;
}

void left_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 1;
	IN4 = 0;
}

void right_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 0;
	IN2 = 1;
	IN3 = 0;
	IN4 = 1;
}

void stop(void)
{
	IN1 = 0;
	IN2 = 0;
	IN3 = 0;
	IN4 = 0;
}
//***************定时器与PWM相关配置***********************

/**** Timer0初始化****/
void Timer0_Init(void)
{
	TMOD |= 0x02;//定时器0，8位自动重装模块
	TH0 = 164;
	TL0 = 164;//11.0592M晶振，12T溢出时间约等于100微秒
	TR0 = 1;//启动定时器0
	ET0 = 1;//允许定时器0中断
	EA	= 1;//总中断允许	
}
 
/***** Timer0中断函数****/
void timer0_int (void) interrupt 1
{
	pwm_val_left++;
	pwm_val_right++;
	if(pwm_val_left<=pwm_left)		leftMotorPwm = 1;  //装载左PWM输出高电平时间
	else leftMotorPwm = 0; 						    //装载左PWM输出低电平时间
	if(pwm_val_left>=PWM_DUTY)		pwm_val_left = 0;	//如果左对比值大于等于最大占空比数据，则为零

	if(pwm_val_right<=pwm_right)	rightMotorPwm = 1; //装载右PWM输出高电平时间
	else rightMotorPwm = 0; 							//装载右PWM输出低电平时间
	if(pwm_val_right>=PWM_DUTY)		pwm_val_right = 0;	//如果右对比值大于等于最大占空比数据，则为零
}
```
这样，就完成了各个模块中软件设计

### 4.2.3 最终程序与烧录方式
综合以上，最终程序如下：
```c
#include <reg52.h>//51头文件

unsigned char	pwm_val_left,pwm_val_right;	//中间变量
unsigned char 	pwm_left,pwm_right;			//定义PWM输出高电平的时间的变量。用户操作PWM的变量。

#define		PWM_DUTY		100			//定义PWM的周期，数值为定时器0溢出周期，假如定时器溢出时间为100us，则PWM周期为10ms。
#define		PWM_HIGH_MIN	35			//限制PWM输出的最小占空比。
#define		PWM_HIGH_MAX	PWM_DUTY	//限制PWM输出的最大占空比。


/*电机驱动IO定义*/
sbit leftMotorPwm = P1^5; //为1 左电机使能
sbit IN1 = P1^4; //为1 左电机正转
sbit IN2 = P1^3; //为1 左电机反转
sbit IN3 = P1^2; //为1 右电机反转
sbit IN4 = P1^1; //为1 右电机正转
sbit rightMotorPwm = P1^0; //为1 右电机使能

sbit leftSensor = P3^4;//左传感器 为0 没有识别到黑线 为1识别到黑线 
sbit rightSensor = P3^5;//右传感器	为0 没有识别到黑线 为1识别到黑线

void Timer0_Init(void); //定时器0初始化
void LoadPWM(void);//装入PWM输出值 
void forward(unsigned char LeftSpeed,unsigned char RightSpeed);//小车前进 
void left_run(unsigned char LeftSpeed,unsigned char RightSpeed);//小车左转  
void right_run(unsigned char LeftSpeed,unsigned char RightSpeed);//小车右转
void stop(void);//小车停车

void Tracking()
{
	//为0 没有识别到黑线 为1识别到黑线
	char data1,data2 = leftSensor,data3 = rightSensor;
	data1 = data2*10+data3;
	if(data1 == 11)//在黑线上，前进
	{
		//forward(120,120);//前进
		forward(70,70);//前进
	}
	else
	{
	 	if(data1 == 10)//小幅偏右，左转 
		{
			//left_run(80,160);//左转
			left_run(70,70);//左转  
		}
		if(data1 == 1)//小幅偏左，右转  
		{
			//right_run(160,80);//右转
			right_run(70,70);//右转  
		}
		if(data1 == 0)//大幅偏左或偏右，已脱离轨道
		{
			stop();	
		}
	}
}

/*主函数*/     
void main(void)
{
	Timer0_Init();//定时0初始化
	while(1)
	{
		Tracking();
	}	
}



void forward(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 0;
	IN4 = 1;
}

void left_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 1;
	IN2 = 0;
	IN3 = 1;
	IN4 = 0;
}

void right_run(unsigned char LeftSpeed,unsigned char RightSpeed)
{
	pwm_left = LeftSpeed,pwm_right =  RightSpeed;//设置速度
	IN1 = 0;
	IN2 = 1;
	IN3 = 0;
	IN4 = 1;
}

void stop(void)
{
	IN1 = 0;
	IN2 = 1;
	IN3 = 1;
	IN4 = 0;
}

/********************* Timer0初始化************************/
void Timer0_Init(void)
{
	TMOD |= 0x02;//定时器0，8位自动重装模块
	TH0 = 164;
	TL0 = 164;//11.0592M晶振，12T溢出时间约等于100微秒
	TR0 = 1;//启动定时器0
	ET0 = 1;//允许定时器0中断
	EA	= 1;//总中断允许	
}
 
/********************* Timer0中断函数************************/
void timer0_int (void) interrupt 1
{
	pwm_val_left++;
	pwm_val_right++;
	if(pwm_left > PWM_HIGH_MAX)		pwm_left = PWM_HIGH_MAX;	//如果左输出写入大于最大占空比数据，则强制为最大占空比。
	if(pwm_left < PWM_HIGH_MIN)		pwm_left = PWM_HIGH_MIN;	//如果左输出写入小于最小占空比数据，则强制为最小占空比。
	if(pwm_right > PWM_HIGH_MAX)	pwm_right = PWM_HIGH_MAX;	//如果右输出写入大于最大占空比数据，则强制为最大占空比。
	if(pwm_right < PWM_HIGH_MIN)	pwm_right = PWM_HIGH_MIN;	//如果右输出写入小于最小占空比数据，则强制为最小占空比。
	
	if(pwm_val_left<=pwm_left)		leftMotorPwm = 1;  //装载左PWM输出高电平时间
	else leftMotorPwm = 0; 						    //装载左PWM输出低电平时间
	if(pwm_val_left>=PWM_DUTY)		pwm_val_left = 0;	//如果左对比值大于等于最大占空比数据，则为零

	if(pwm_val_right<=pwm_right)	rightMotorPwm = 1; //装载右PWM输出高电平时间
	else rightMotorPwm = 0; 							//装载右PWM输出低电平时间
	if(pwm_val_right>=PWM_DUTY)		pwm_val_right = 0;	//如果右对比值大于等于最大占空比数据，则为零
}
```
**烧录到小车方式**

1. 编译生成hex格式的文件，这也就是需要烧录到小车的文件，注意编译前需要在软件设置：
首先点击这里：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211233944.png#crop=0&crop=0&crop=1&crop=1&id=xROLn&originHeight=784&originWidth=1089&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

接着：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211234235.png#crop=0&crop=0&crop=1&crop=1&id=blAmX&originHeight=859&originWidth=1288&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

然后编译：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211234324.png#crop=0&crop=0&crop=1&crop=1&id=jVy6u&originHeight=529&originWidth=964&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

可以发现，编译后生成了hex文件，记住这个文件的位置：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211234510.png#crop=0&crop=0&crop=1&crop=1&id=UM1ZT&originHeight=1016&originWidth=1568&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

2. 烧录到小车： 
   - 首先小车的开发板上接上串口烧录模块：注意这里，只接三根即可，其中`RXD`接另一边的`TXD`，`TXD`接另一边的`RXD`，最后一根为`GND`对应相接即可。
   
   ![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221211235459.png#crop=0&crop=0&crop=1&crop=1&id=xDaHa&originHeight=584&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 
   
   - 然后打开`STC-ISP`软件，选择芯片型号：
   
   ![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212000327.png#crop=0&crop=0&crop=1&crop=1&id=ulnVp&originHeight=583&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 
  
   - 接着打开程序文件，选择之前生成的`hex`文件，其位置一般在编译后会在工程目录下的`Object`文件夹下。
   
   ![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212001002.png#crop=0&crop=0&crop=1&crop=1&id=xKKdx&originHeight=676&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 
   
   - 选择合适的扫描串口，这里在小车通过烧录模块与电脑连接后进行，需要选择带有`CH340`字样的端口，端口号可能与这里不一样：
   
   ![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212001514.png#crop=0&crop=0&crop=1&crop=1&id=GQABL&originHeight=583&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 
   
   - 硬件选项如下：
   
   ![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212001807.png#crop=0&crop=0&crop=1&crop=1&id=iWasP&originHeight=583&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 
   
   - 最后点击下载，点击之前确认小车开发板上的电源已经关闭了，点击后再打开电源，看到操作成功字样代表烧录完成：
   
   ![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212002627.png#crop=0&crop=0&crop=1&crop=1&id=XAQOa&originHeight=583&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
   
   至此，就完成了以51单片机为主控循迹小车的设计，现在可以将小车放在黑线上试一试了。 

# 5 FPGA实现循迹小车
> 在阅读这部分之前，请先理解前面的51单片机中对各个模块的解释，原理是一样的，所以这部分不会对原理进行过多的解释。另外，FPGA设计其实更加简单，但软件的操作却更复杂，如果有不熟悉的操作，可以查看老师发的资料中开发指南第五章里面关于quartus的相关操作。与51单片机作为主控相似，FPGA实现循迹小车的方式是一样的，都是根据红外循迹模块检测的结果来对电机进行相应的控制。当然，51单片机和FPGA在底层上是有很大区别的，大家感兴趣可能自行查阅相关资料。


## 5.1 输入输出关系分析
如果将前面的51单片机看成一个黑匣子，只关心输入与输出，我们可以得到下面的输入输出对应表：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212010614.png#crop=0&crop=0&crop=1&crop=1&id=OvVn4&originHeight=313&originWidth=1078&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

实际的输入除了上面提到的还需要有：系统的时钟与复位信号。这样，循迹小车这个系统就有4个输入，6个输出了。

## 5.2 硬件设计
**引脚连接**
除开，系统时钟和复位信号外，其它的输入输出的引脚可以根据资料中的开发指南部分2.4节进行分配即可。系统时钟和复位信号必须为`PIN17`和`PIN_90`，不过这两个引脚在开发板上已经连接上了，无须手动连接。其它的引脚可以在下表中“FPGA引出I/O”部分选择即可，然后参照之间的51单片机进行连接。

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212014911.png#crop=0&crop=0&crop=1&crop=1&id=TSEAX&originHeight=1172&originWidth=961&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

我们选择引脚如下：


| IN4 | IN3 | IN2 | IN1 | ENA | ENB | 红外（左） | 红外（右） |
| --- | --- | --- | --- | --- | --- | --- | --- |
| PIN_59 | PIN_63 | PIN_65 | PIN_69 | PIN_53 | PIN_57 | PIN_47 | PIN_51 |


**VCC与GND**
除开上面的几个引脚，L298N驱动模块以及红外循迹模块中的`VCC`和`GND`还需要供电，这里我们可以直接使用电池盒引出的供电线与它们对应相连。在这几个引脚对应连接好之后一定要记住再将地线与FPGA开发板上的地连接。连接关系如下：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212211228.png#crop=0&crop=0&crop=1&crop=1&id=O52bu&originHeight=493&originWidth=617&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

**实物图如下：**

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img6F4F2B3E621098E61EDE2B28A4B0E6FC.jpg#crop=0&crop=0&crop=1&crop=1&id=owPKf&originHeight=3000&originWidth=4000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

上图即为小车以`FPGA`为主控的连线方式，但上面的连线还缺少为开发板供电的连线。因为电池的引出线无法直接用于为开发板供电，大家可以使用包装中的电源适配器供电或使用USB转DC的线连接充电宝供电。
电源适配器：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212212606.png#crop=0&crop=0&crop=1&crop=1&id=PvyqK&originHeight=358&originWidth=460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

USB转DC的线连接充电宝：

![|300](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212213123.png#crop=0&crop=0&crop=1&crop=1&id=Z0ggF&originHeight=368&originWidth=278&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

## 5.3 软件设计
以`FPGA`为主控的软件设计流程与前面以51单片机为主控是一致的。

1. 首先，导入对应的`VHDL`库和软件包，这里用到了软件包`std_logic_1164`，是为了使用`STD_LOGIC`和`STD_LOGIC_VECTOR`这两种数据类型；然后定义实体指定输入输出类型：
```vhdl
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY cartracking IS
GENERIC (
--时钟为50MHz，为了产生100Hz的PWM波，设置计数值为500000
cnt_meta   : INTEGER := 500000;
--对应了停止、前进、左转、右转状态IN4到IN1的输出
StopCar       : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0000";
Forward    : STD_LOGIC_VECTOR(3 DOWNTO 0) := "1001";
Left_Go    : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0101";
Right_Go   : STD_LOGIC_VECTOR(3 DOWNTO 0) := "1010"
);
--******************输入输出端口***********************
PORT (
sys_clk    : IN STD_LOGIC;
sys_rst_n  : IN STD_LOGIC;
infrared   : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
pwm_left   : OUT STD_LOGIC;
pwm_right  : OUT STD_LOGIC;
in_motor   : OUT STD_LOGIC_VECTOR(3 DOWNTO 0)
);
END cartracking;
```

2. 在小车电源打开后，不停地检测红外循迹模块传来的数据，并完成对应的转向与转速的设置：
```vhdl
PROCESS (sys_rst_n, infrared)
   BEGIN
      IF (sys_rst_n = '0') THEN
         duty_right <= 60;
         duty_left <= 60;
      ELSE
         CASE infrared IS
            WHEN "00" =>
               in_motor <= StopCar;
            WHEN "01" =>
               in_motor <= Right_Go;
               --PWM波的占空比，设置合适的值来控制小车的转速，这里为了在仿真时可以对比，我将左右轮设置了不同的占空比，你可以在调试时尝试更合适的值。
               duty_left <= 35;
               duty_right <= 55;
            WHEN "10" =>
               in_motor <= Left_Go;
               duty_left <= 55;
               duty_right <= 35;
            WHEN OTHERS =>
               in_motor <= Forward;
               duty_left <= 50;
               duty_right <= 50;
         END CASE;
      END IF;
   END PROCESS;
```

3. 为了产生`PWM`波，需要用到与前面以51单片机为主控时一样的原理，也就是通过对时钟信号上升沿计数，计数到一定值重新计数。并在计数的过程中不断将当前计数值与设定的某个值进行对比，小于则输出低电平，大于则输出高电平。最终生成`PWM`波，详细的过程可能参考前面以51单片机为主控的部分。代码如下：
```vhdl
PROCESS (sys_clk, sys_rst_n)
   BEGIN
      IF (sys_rst_n = '0') THEN
         cnt <= 0;
      ELSIF (sys_clk'EVENT AND sys_clk = '1') THEN
         IF (cnt = cnt_meta) THEN
            cnt <= 0;
         ELSE
            cnt <= cnt + 1;
         END IF;
      END IF;
   END PROCESS;
   
   
   PROCESS (sys_clk, sys_rst_n)
   BEGIN
      IF (sys_rst_n = '0') THEN
         pwm_left <= '0';
         pwm_right <= '0';
      ELSIF (sys_clk'EVENT AND sys_clk = '1') THEN
         IF (cnt >= (cnt_meta / 100)* duty_left) THEN
            pwm_left <= '0';
         ELSE
            pwm_left <= '1';
         END IF;
         
         IF (cnt >= (cnt_meta / 100) * duty_right) THEN
            pwm_right <= '0';
         ELSE
            pwm_right <= '1';
         END IF;
      END IF;
   END PROCESS;
```
综上，得到最终代码如下：
```vhdl
LIBRARY ieee;
   USE ieee.std_logic_1164.all;

ENTITY cartracking IS
   GENERIC (
      --时钟为50MHz，为了产生100Hz的PWM波，设置计数值为500000
      cnt_meta   : INTEGER := 500000;
      --对应了停止、前进、左转、右转状态IN4到IN1的输出
      StopCar       : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0000";
      Forward    : STD_LOGIC_VECTOR(3 DOWNTO 0) := "1001";
      Left_Go    : STD_LOGIC_VECTOR(3 DOWNTO 0) := "0101";
      Right_Go   : STD_LOGIC_VECTOR(3 DOWNTO 0) := "1010"
   );
   --******************输入输出端口***********************
   PORT (
      sys_clk    : IN STD_LOGIC;
      sys_rst_n  : IN STD_LOGIC;
      infrared   : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
      pwm_left   : OUT STD_LOGIC;
      pwm_right  : OUT STD_LOGIC;
      in_motor   : OUT STD_LOGIC_VECTOR(3 DOWNTO 0)
   );
END cartracking;

ARCHITECTURE trans OF cartracking IS
   
   SIGNAL cnt        : INTEGER;
   SIGNAL duty_left  : INTEGER;
   SIGNAL duty_right : INTEGER;
BEGIN
   PROCESS (sys_rst_n, infrared)
   BEGIN
      IF (sys_rst_n = '0') THEN
         duty_right <= 60;
         duty_left <= 60;
      ELSE
         CASE infrared IS
            WHEN "00" =>
               in_motor <= StopCar;
            WHEN "01" =>
               in_motor <= Right_Go;
               --PWM波的占空比，设置合适的值来控制小车的转速，这里为了在仿真时可以对比，我将左右轮设置了不同的占空比，你可以在调试时尝试更合适的值。
               duty_left <= 35;
               duty_right <= 55;
            WHEN "10" =>
               in_motor <= Left_Go;
               duty_left <= 55;
               duty_right <= 35;
            WHEN OTHERS =>
               in_motor <= Forward;
               duty_left <= 50;
               duty_right <= 50;
         END CASE;
      END IF;
   END PROCESS;
   
   PROCESS (sys_clk, sys_rst_n)
   BEGIN
      IF (sys_rst_n = '0') THEN
         cnt <= 0;
      ELSIF (sys_clk'EVENT AND sys_clk = '1') THEN
         IF (cnt = cnt_meta) THEN
            cnt <= 0;
         ELSE
            cnt <= cnt + 1;
         END IF;
      END IF;
   END PROCESS;
   
   
   PROCESS (sys_clk, sys_rst_n)
   BEGIN
      IF (sys_rst_n = '0') THEN
         pwm_left <= '0';
         pwm_right <= '0';
      ELSIF (sys_clk'EVENT AND sys_clk = '1') THEN
         IF (cnt >= (cnt_meta / 100)* duty_left) THEN
            pwm_left <= '0';
         ELSE
            pwm_left <= '1';
         END IF;
         
         IF (cnt >= (cnt_meta / 100) * duty_right) THEN
            pwm_right <= '0';
         ELSE
            pwm_right <= '1';
         END IF;
      END IF;
   END PROCESS;
   
   
END trans;
```

利用Quartus进行仿真和程序固化在资料中第五章有详细的教程，请参考完成，这里对注意事项进行说明：
1. 上面的最终代码中，我设置的实体名为`cartracking`，这是需要和工程中的顶层文件名一致的，有如下两种方式。
	方法一：代码中修改实体名`cartracking`为你工程设置的顶层文件名：
![image.png|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221220210434.png)
	方法二：修改你的工程中自己设置的顶层文件名为`cartracking`

![image.png|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221220205801.png)
![image.png|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221220210725.png)



2.  仿真时，因为按照实际的情况，红外模块检测到出线与否的时间（ms级）相对于时钟周期（ns级）差距太大，因此为了完成仿真可以对程序中的计数周期和红外模块检测周期进行适当的缩小（**注：程序在最后烧录时记得改回来**）。
程序修改部分： 
```
...
GENERIC (
  --时钟为50MHz，为了产生100Hz的PWM波，设置计数值为500000
  cnt_meta   : INTEGER := 500; --为了仿真改为500，烧录时需改回去
...
```

3.  仿真的输入信号设置（可以作为参考，你可能自行设置合适的输入波形）：
4. 
![image.png|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221223223734.png)


上图中，复位信号的设置方法为：

![image.png|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221220213131.png)

上图中，周期设置方法为：
	
![image.png|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221220212048.png)

功能仿真结果如下：

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212224734.png#crop=0&crop=0&crop=1&crop=1&id=yXeit&originHeight=372&originWidth=1808&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

5.  程序烧录前，记得将仿真修改的部分改回去，重新编译后再进行下载。
完成仿真与程序烧录后，可以通过充电宝或者电源适配器为`FPGA`开发板进行供电，然后对循迹小车进行测试。小车正常循迹后，以`FPGA`为主控的循迹小车的设计完成。

![|500](https://pic-1312640559.cos.ap-chengdu.myqcloud.com/img20221212230245.png#crop=0&crop=0&crop=1&crop=1&id=S8jI1&originHeight=1028&originWidth=721&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=) 
